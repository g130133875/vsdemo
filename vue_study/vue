vue基本指令:
  v-for
  v-once: 只显示一次
  v-html: 解析html
  v-text
  v-pre: 不解析{{}}
  v-cloak 

v-bind:
  动态绑定属性
    eg: <img （v-bind）:src=" ">

var let const的区别:
  var: 作用域为函数
  let: 作用域为块
  const: 修饰后不可修改且必须赋值(对象内部的属性可修改)

vue常用指令
  v-on的参数问题:
  事件调用的方法没有参数可省略小括号
  如果有参数没有写则函数的形参为undefined
  在调用方法，手动获取到浏览器参数的event对象: $event

  v-on修饰符:
    .stop 停止冒泡
    .prevent 阻止默认行为 
    .{keyCode | keyAlias} 只当事件是从特定建触发时才触发回调
    .native 监听组件根元素的原生事件
    .once 只触发一次回调

  v-if、v-else-if、v-else
    v-if后面的条件为false时，对应的元素以及子元素不会渲染
  v-show:
    v-if: 条件为false时，包含v-if指令的元素，DOM中不会存在对应的元素
    v-show: display:none，适用于切换频率高的情况


  组件的key属性:
    使用v-for时给对应组件添加:key属性
    作用：高效的更新虚拟DOM


  可以做到响应式的数组方法:
    push()
    pop()
    shift(): 删除第一个元素
    unshift(): 在前面添加元素
    splice(位置，删除元素个数，插入的元素): 删除/插入/替换元素
    sort()
    reverse(): 反转

高阶函数filter/map/reduce
  filter:
    回调函数有一个要求:返回一个boolean的值
    true: 函数内部将回调的n加入新数组
    false: 函数内部过滤掉n
  map:
    eg:
      let newNums = nums.map(function (n){
        return n*2;
      }) 
  reduce: 对数组中所有的内容进行汇总
    eg:
      let total = nums.reduce(function (preValue, n) {
        return preValue+n;
      },0)

v-model
  实现双向绑定
  修饰符: lazy, number, trim
    lazy: 失去焦点或者回车后更新
    number: 输入的内容自动转换成数字类型
    trim: 可以过滤左右两边空格

组件化开发
  组件中的data必须是个函数，且返回实例
  父子组件的访问方式: $children
    父组件访问子组件：使用$children或$refs
    子组件访问父组件: 使用$parent
  slot: 让组件更具有拓展性
    对象： 有许多区别同时有许多共性的组件
    方法： 抽取共性，保留不同
  具名插槽: 给slot命名方便修改属性

模块化开发
  模块化核心：导入和导出
    CommonJS的导出：
      module.exports = {
        flag: true,
        test(a, b) {
          return a+b
        }
      }
    CommonJS的导入:
      let {flag, test} = require('moduleA');

Webpack
  JavaScript应用的静态模板打包工具:前端模块化打包工具
  全局安装:
    npm install webpack@3.6.0 -g
  局部安装:
    npm install webpack@3.6.0 --save-dev

Vue CLI
  脚手架：自动进行webpack配置
  安装：
    脚手架3：npm install @vue/cli(@指定版本)
            vue create my-project
    脚手架2：npm install @vue/cli-init -g
            vue init webpack my-project 
  卸载：
    npm uninstall -g @vue/cli

箭头函数：
  const c = (参数列表) => { }
  //箭头函数中的this引用的就是最近作用域中的this
  const obj = {
    aaa() {
      setTimeout(function () {
        console.log(this);  //window
      })

      setTimeout(() => {
        console.log(this);  //obj
      })
    }
  }

router
  安装：
    步骤一： 安装vue-router
      npm install vue-router --save
    步骤二： 在模块化中使用
      1. 导入路由对象，并且调用Vue.use(VueRouter)
      2. 创建路由实例，并且传入路由映射配置
      3. 在Vue实例中挂载创建的路由实例
  使用：
    1. 创建路由组件
    2. 配置路由映射：组件和路径映射关系
    3. 使用路由：通过<router-link>和<router-view>

router-link: 可通过按钮方法(this.$router.push('/路径'))来实现
  tag: 指定渲染组件类型
  replace: 不会留下history记录，所以指定replace的情况下后退键不能返回到上一个页面中
  active-class： 对应的路由匹配成功时，自动给当前元素设置一个router-link-active的类
  动态路由：$route.params.userId

传递参数的方式：
  params的类型：
    配置路由格式：/router/:id
    传递的方式：在path后面跟上对应的值
    传递后形成的路径：/router/id
  query的类型：
    配置路由格式：/router，普通配置
    传递的方式：对象中使用query的key作为传递方式
    传递后形成的路径：/router?id=xx

$route和$router的区别：
  $router为VueRouter实例，想要导航到不同URL，则使用$router.push方法
  $route为当前router跳转对象里面可以获取name、path、query、params等

导航守卫：
  vue-router提供的导航守卫主要用来监听路由的进入和离开
  vue-router提供了beforeEach和afterEach的钩子函数，它们会在路由即将改变前和改变后触发
导航守卫的使用：
  利用beforeEach来完成标题的修改：
    1.在钩子中定义一些标题，可利用meta来定义
    2.利用导航守卫修改标题
导航钩子：前置钩子beforeEach，后置钩子afterEach（不需要调用next）
  router.beforeEach(to,from,next) => {
  document.title = to.matched[0].meta.title
  console.log(to)
  next()}
  to：即将要进入的目标的路由对象
  from：当前导航即将要离开的路由对象
  next：调用该方法后，才能进入下一个钩子

keep-alive
  可缓存所包含的视图组件